{
    "datetime": "2024-11-01",
    "user": "U07QEMYKQP4",
    "name": "mineshds",
    "real_name": "minesh sani",
    "text": "Hello all,\nI have a question about datasets and namespaces. I am not even sure if what I am asking for is possible.\nHere is a simplified version of the issue:\n\nI have postgresql database which updates daily with data (predictions from some other models but that is beside the point)\nOne of the columns in the results_table is called \"run_date\". So if I want today's results I can do this:\n\n(in catalog.yml):\n\n`oneday_of_data:`\n  `type: pandas.SQLQueryDataset`\n  `credentials: db_credentials`\n  `sql: \"select * from results_table where run_date = %(run_date)s\"`\n  `load_args:`\n    `params:`\n      `run_date: 2024-11-01`\n\nthis dataset combined with this one node pipeline lets me get the data from the database into my local drive.\n\n(in pipeline.py)\n\n`pipeline([`\n\t\t\t\t\t`node(`\n\t\t\t\t\t\t`func=lambda x: x,`\n\t\t\t\t\t\t`inputs=\"database_data\",`\n\t\t\t\t\t\t`outputs=\"local_data\",`\n\t\t\t\t\t\t`name=\"sql_to_local_node\"`\n\t\t\t\t\t`),]`\n\t\t  `)`\n\nnow, if I wanted more than one day's data as different datasets, it seems like this a great candidate for namespacing because nothing changes except for the run date. Like this:\n\n(in catalog.yml)\n`_run_dates:`\n  `run_1: 2024-11-01 #today`\n  `run_2: 2024-10-30 #yesterday`\n  `run_3: 2024-10-25 #a week ago`\n\n`\"{run_name}.oneday_of_data\":`\n  `type: pandas.SQLQueryDataset`\n  `credentials: db_credentials`\n  `sql: \"select * from results_table where run_date = %(run_date)\"`\n  `load_args:`\n    `params:`\n      `run_date: ${_run_dates.{run_name}}`\n\nbut no matter what I try I can't get this to work. I know I can specify {run_name} in the filepath field (if it was a csv dataset say) but is it possible to use inside a templated/variable-interpolated field like this?\n\nI have tried writing my own custom resolver (called \"picker\") defined as:\n\n(in settings.py)\n`def pick_from_rundates(dict1, key):`\n    `return dict1[key]`\n\n`CONFIG_LOADER_ARGS = {`\n      `\"base_env\": \"base\",`\n      `\"default_run_env\": \"local\",`\n      `\"custom_resolvers\": {\"picker\": lambda x, y: pick_from_rundates(x, y)}`\n`}`\n\n\nand then tried this...which also failed:\n\n(in catalog.yml)\n`\"{run_name}.oneday_of_data\":`\n  `type: pandas.SQLQueryDataset`\n  `credentials: db_credentials`\n  `sql: \"select * from results_table where run_date = %(run_date)\"`\n  `load_args:`\n    `params:`\n      `run_date: ${picker:${_run_dates},\"{run_name}\"}`\n\nSo am I missing something simple here or is this fundamentally not allowed? Ideally the run dates would be specified in from the globals.yml instead of directly in the catalog.yml but I am trying to walk before I run here.\n\nI will be grateful for any advice here.\nminesh",
    "reply_count": 1,
    "reply_users_count": 1,
    "reply_users": [
        "U05JMSKG6MT"
    ],
    "replies": [
        {
            "user": "U05JMSKG6MT",
            "ts": "1730479258.946419",
            "datetime": "2024-11-01",
            "name": "yury_fedotov",
            "real_name": "Yury Fedotov",
            "text": "Not sure if it satisfies your goal, but a workaround could be:\n1. Make your function take a list of dates, instead of a single date\n2. Load all this as a single table from the DB\n3. Partition into dates, and save as `PartitionedDataset` where something like `f\"predictions{date}\"` is key and corresponding predictions are value\nSo this turns your:\n\n> ...if I wanted more than one day's data as different datasets...\nInto a *single dataset, but multiple files*"
        }
    ]
}